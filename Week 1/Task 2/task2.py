# -*- coding: utf-8 -*-
"""task2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1etC7mMUsmDV7rXQ-5aox3ekfombIPfAy
"""

import numpy as np
import matplotlib.pyplot as plt
import json
import time

seed = 1
np.random.seed(seed)

N = 100            # number of particles
a = 1.0            # particle diameter
phi = 0.3          # area fraction
v0 = 1.0           # self-propulsion speed
Dr = 0.1           # rotational diffusion coefficient
mu = 1.0           # mobility (multiplies forces)
k = 100.0          # harmonic force constant
dt = 0.01          # time step (smaller dt for stability with forces)
tmax = 200.0       # total simulation time
sample_every = 10  # record MSD every this many steps

area_per_particle = np.pi * (a/2.0)**2
total_area = N * area_per_particle / phi
L = np.sqrt(total_area)   # box side length
steps = int(np.ceil(tmax / dt))

print("N =", N, "phi =", phi, "L =", round(L, 3))
print("v0 =", v0, "Dr =", Dr, "dt =", dt, "steps =", steps)

params = dict(N=N, a=a, phi=phi, v0=v0, Dr=Dr, mu=mu, k=k, dt=dt, tmax=tmax,
              sample_every=sample_every, L=L, seed=seed)
with open("params_task2.json", "w") as f:
    json.dump(params, f, indent=2)
print("Saved simulation parameters to params_task2.json")

# Initialize positions and orientations

pos = np.random.rand(N, 2) * L     # wrapped positions [0,L)
theta = np.random.rand(N) * 2*np.pi

# unwrapped positions for displacement-based observables (MSD)
pos_unwrapped = pos.copy()
pos0 = pos_unwrapped.copy()

# Pre-allocate MSD arrays
n_records = steps // sample_every + 1
times = np.zeros(n_records)
msd = np.zeros(n_records)
times[0] = 0.0
msd[0] = 0.0

# helper for rotational noise
sqrt2Dr_dt = np.sqrt(2.0 * Dr * dt)

# interaction cutoff: harmonic repulsion acts when r < a
rc = a

def compute_forces(positions, L, N, k, rc):
    """
    positions: (N,2) array of wrapped positions in box [0,L)
    returns: forces (N,2) in lab frame using minimum image convention
    """
    forces = np.zeros_like(positions)
    for i in range(N):
        ri = positions[i]
        for j in range(i+1, N):
            rj = positions[j]
            # minimum image separation
            dr = rj - ri
            dr -= L * np.round(dr / L)
            dist = np.linalg.norm(dr)
            if dist == 0:
                continue
            if dist < rc:
                # harmonic repulsion magnitude
                # F = k * (rc - r)
                fmag = k * (rc - dist)
                # unit vector from i->j
                fvec = (fmag / dist) * dr
                # apply: i feels -fvec, j feels +fvec
                forces[i] -= fvec
                forces[j] += fvec
    return forces

record_idx = 1
t0 = time.time()

for istep in range(1, steps+1):
    # rotational diffusion
    dtheta = np.random.normal(0.0, 1.0, size=N) * sqrt2Dr_dt
    theta += dtheta

    # unit propulsion vectors
    e_x = np.cos(theta)
    e_y = np.sin(theta)
    e_vec = np.vstack([e_x, e_y]).T  # shape (N,2)

    # compute pairwise forces (O(N^2))
    forces = compute_forces(pos, L, N, k, rc)

    # deterministic displacement (v0*e + mu*F) * dt
    drift = (v0 * e_vec + mu * forces) * dt

    # update positions (wrapped for dynamics, unwrapped for MSD)
    pos += drift
    pos_unwrapped += drift

    # apply periodic boundary conditions to wrapped positions
    pos %= L

    # record MSD occasionally
    if (istep % sample_every) == 0:
        t = istep * dt
        dr2 = (pos_unwrapped - pos0)**2
        dr2_sum = dr2.sum(axis=1)
        msd_val = dr2_sum.mean()
        times[record_idx] = t
        msd[record_idx] = msd_val
        record_idx += 1

        # light progress print
        if record_idx % (n_records // 10 + 1) == 0:
            elapsed = time.time() - t0
            pct = 100.0 * istep / steps
            print(f"step {istep}/{steps} ({pct:.1f}%), t={t:.2f}, msd={msd_val:.3f}, elapsed={elapsed:.1f}s")

# ----------------------------
# Save results and plots
# ----------------------------
np.savez("task2_traj.npz", pos=pos, pos_unwrapped=pos_unwrapped, theta=theta, times=times, msd=msd, params=params)
print("Saved trajectory and arrays to task2_traj.npz")

ballistic = (v0**2) * times**2
diffusive = (2.0 * v0**2 / Dr) * times

fig, axs = plt.subplots(1, 2, figsize=(12,5))

ax = axs[0]
ax.plot(times, msd, label="MSD (sim)")
ax.plot(times, ballistic, '--', label="~ t^2")
ax.plot(times, diffusive, '--', label="~ t")
ax.set_xlabel("time")
ax.set_ylabel("MSD")
ax.set_title("MSD vs time (linear) — with repulsion")
ax.legend()
ax.grid(True)

ax = axs[1]
mask = times > 0
ax.loglog(times[mask], msd[mask], label="MSD (sim)")
ax.loglog(times[mask], ballistic[mask], '--', label="~ t^2")
ax.loglog(times[mask], diffusive[mask], '--', label="~ t")
ax.set_xlabel("time")
ax.set_ylabel("MSD")
ax.set_title("MSD vs time (log-log) — with repulsion")
ax.legend()
ax.grid(True, which="both", ls=":")

plt.tight_layout()
plt.savefig("msd_task2.png", dpi=200)
print("Saved msd plot to msd_task2.png")
plt.show()

# final snapshot plot of particle positions (wrapped)
plt.figure(figsize=(6,6))
plt.scatter(pos[:,0], pos[:,1], s=20, alpha=0.8)
plt.xlim(0, L)
plt.ylim(0, L)
plt.gca().set_aspect('equal', 'box')
plt.title("Final snapshot (wrapped positions)")
plt.savefig("snapshot_task2.png", dpi=200)
print("Saved snapshot to snapshot_task2.png")
plt.show()

print("Done.")